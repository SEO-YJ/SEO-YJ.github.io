---
layout: post
title:  "우리.. 이것만 알아도 협업할 수 있을까?"
date:   2022-05-04 15:38:00 +0900
categories: Git알못을 위한 깃린이코스(Git, Github 실습위주) 정리
---
# 브랜치 몰라도 협업하는 방법
### Q. 브랜치를 몰라도 협업할 수 있나요?
가능은 합니다.
다만, 힘들고, 섹시하지 않습니다!

브랜치를 모르고 협업하는 경우
노트북과 데스크탑 두 개를 번갈아 가면서 쓰는 경우와 같다.

## 브랜치를 사용하지 않을 경우 협업에서의 문제
컴퓨터1 에서 커밋 a -> 커밋 c 푸시
컴퓨터2 에서 커밋 a, c 를 클론
컴퓨터1 에서 커밋 a,c,d 만들어서 푸시
컴퓨터2 에서 커밋 a,c,q 만들어서 푸시
그러면, 커밋 d는 사라지지 않을까?
아 애초에, 
컴퓨터1 에서 커밋 a,c,d를 만들어서 푸시하면
컴퓨터2 에서 커밋 a,c,q를 만들어서 푸시하려 하면 깃허브에서 거절이 된다.

### 내 생각
개인 프로젝트라면 상관 없겠지만, 
협업에서는 브랜치를 사용하는 것이
커밋의 흐름에 있어서 매우 중요할 것이라는 생각이 든다.
다른 사람이 커밋한 것이 생략될 수 있기 때문이다.

### 답
혼자서 진행하는 경우에는
두 컴퓨터에서 커밋이 동시에 만들어지지 않으니까 상관이 없으나,
푸시를 하고, 다른 컴퓨터에서 풀을 한 후에 작업을 하면 되므로...

## 영리한 깃이 위 문제를 해결해 준다.
컴퓨터2 에서 풀을 하면, a,c,d,q로 순서를 정해준다.
하지만, 상대방이 커밋 업데이트를 했는지, 풀을 통해 확인해주어야 한다.

### 서로 같은 파일의 같은 줄의 코드를 건드렸다면
conflict 발생

## 브랜치를 배우는 이유
1. 브랜치를 모르면 불편하다.
2. 브랜치만 알아도 협업이 가능하다.

# 브랜치 몰라도 협업하는 방법, 실전편
## 내 리포지토리에 협업자 초대하는 방법
1. 리포지토리 들어가기
2. manage access
3. Invite a collaborator to CoWorkTestNoBranch
4. 이름 검색 후 초대
5. 협업자에게 승인 관련 메일이 오면 승인하면 된다.
6. 협업자는 git clone 리포지토리주소 해서 리포지토리 로컬에 가져오면 된다.

### 문제 상황
1. 본 계정에서도 커밋하고, 협업자도 커밋을 하는 경우
2. 본 계정은 깃 허브 페이지에서 커밋을 한다. (그러면, 푸시까지 자동으로 진행된다.)
3. 협업자의 로컬에서는 하직 커밋 1개만 있을 것이다. ( 본 계정에서 추가한 커밋은 X)
4. 협업자의 로컬에서 새로운 커밋을 만든 후, 리모트에 푸시를 해본다.
에러 발생!!!
[rejected] main -> main (fetch first)
이유: 리모트에 a -> b 커밋이 되어있는데, 협업자가 a -> c 커밋을 푸시하면 커밋 b가 사라지므로
에러 해결 방법
git pull origin main 으로 리모트의 커밋을 땡겨온다.
그러면, 로컬에 커밋을 한 시간대로 연결된다. (a -> b -> c)

### 만약에 리모트에서와 로컬에서 동일한 파일을 수정한 후 동시 커밋을 하면 어떻게 될까?
confilct 문제 발생

# CONFLICT!! 같은 파일을 수정해서 충돌이 났을 경우
## CONFLICT란?
커밋의 순서가 꼬이고, 같은 파일의 같은 부분을 수정할 경우
같은 부분: 같은 코드라인
## 문제 발생
git pull을 진행할 경우,
리모트의 코드라인이 맞는지, 로컬의 코드라인이 맞는지 깃은 알 수가 없어 'Conflict'에러를 발생시킨다.
CONFLICT (content) : Merge conflict in 파일명(ex> shinplest.txt) 와 같은 에러가 발생된다.

## CONFLICT 해결 방법
1. 로컬의 같은 파일, 같은 부분의 코드라인을 '리모트의 코드라인'으로 변경하여,
add -> commit -> push를 진행한다.


## 지금까지 배운 명령어 정리
### git --version
: 현재 로컬에 설치된 git 버전관리 툴의 버전을 확인할 수 있는 명령어

### git config --global init.defaultBranch main
: git의 root 브랜치가 master -> main으로 변경되었으므로,
main으로 초기에 세팅해주는 명령어
1회만 명령해주면 된다.

### git config --global user.name "YUJUN SEO"
: 현재 로컬의 git의 이름을 환경 설정 해주는 명령어

### git config --global user.email "yujun@~"
: 현재 로컬의 git의 이메일을 환경 설정 해주는 명령어

### git config --list
: 환경 설정 세팅을 확인하는 명령어

### git init
: 폴더 안에 git 파일을 넣어 git으로 관리해주는 명령어
(사진사 고용)
* 강의 자료
1) .git 폴더 생성
2) .git 폴더가 생성된 폴더는 git이 관리하기 시작함

### git add .
: 현재까지 수행한 저장된 파일들을 임시의 공간에 '모두' 저장하는 명령어
( 사진에 찍힐 사람들을 한꺼번에 모으는 명령어)
* 강의 자료
1) 모든 파일 스테이징 (말이 어렵지만 '추적'을 시작한다라고 보면 된다.)

### git add <file명>
: 현재까지 수행한 저장된 파일 중 '특정 파일'을 임시의 공간에 저장하는 명령어
( 사진에 찍힐 사람들 중 특정 사람들을 골라 모으는 명령어)

### git commit -m "message"
: git add를 통해 임시로 저장된 파일들을 버전으로 관리하여 저장하는 명령어
( 사진의 이름, 저장된 파일들, 로컬에 저장된 환경 상태, 날짜 등을 확인 가능)
* 강의 자료
1) message 이름으로 현재 추적하고 있는 코드들을 '찰칵'

### git log
: 현재까지 git commit 명령어로 버전 관리된 파일들을 리스트로 확인하는 명령어
( 앨범)
* 강의 자료
1) 커밋 로그를 확인

### git status
: 프로젝트 내부의 파일들이 '임시의 공간'에 저장되었는지 확인하는 명령어
* 강의 자료
1) 현재 git의 상태를 보여줌

### git rm --cached <file>
: git add 명령어를 통해 임시의 공간에 저장된 파일들 중, 
특정 파일을 선택해 임시의 공간에서 제거하는 명령어
(너 나와봐!)

### git restore
: git add를 통해 임시의 공간에 파일을 저장해 놓았는데,
저장한 파일을 수정하였다가 다시 add를 명령했던 상태로 돌아가고 싶을 때, 사용하는 명령어

### git reset --hard 커밋해쉬코드(번호)
: 이전 commit으로 되돌리고 싶을때 사용하는 명령어
* 강의 자료
1) 커밋 번호에 해당하는 커밋으로 코드를 롤백

### git reset --hard
: commit을 한 후에, 파일들을 수정하던 중 다시 이전 'commit'의 상태로 파일들을 되돌리고 싶을 때 사용하는 명령어

### git remote add origin https://github.com/.... 
라는 명령어를 명령해주면 된다.
git remote add origin (주소)
주소 부분은 Quick setup -- if you've done this kind of thing before
의 HTTPS 부분의 주소를 복사해서 넣어줘도 된다.
3. 리모트에 로컬의 커밋한 내용들을 보내고 싶을 때 사용하는 명령어

### git push origin main
4. commit을 확인해보고 싶으면, commits 부분을 확인하면 된다.

### git clone 레포지토리주소
리모트에 있는 레포지토리 파일들을 복사해서 가져올 수 있다.

### git pull origin main
서버 자체에서 변경이 일어났을 때 가져오는 방법
ex> Add readme

### git reset --hard 커밋해쉬코드(번호)
이전 커밋으로 돌아가는 것도 가능하고,
다시 앞의 커밋으로 되돌리는 것도 가능하다.

